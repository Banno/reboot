Bargaining with promises
------------------------

Applying a future is like taking a hostage. Your demands might be met
in time, but until they are you're sitting around doing nothing other
than guarding a prisoner.

So we don't like to take hostages or apply futures, but what good is
a future if you can't do anything with its value? Luckily, you can do
plenty. You just have to be flexible about when things happen.

### Transformations

A future is like an option that doesn't know what it is yet; think of it as a promise
of having a value in the future. We could transform an option of a string into an
option of its length. Same goes for futures.

```scala
import dispatch._
val svc = url("http://httpbin.org/ip")
val ip = Http(svc OK as.String)
val length = for (c <- ip) yield c.length
```
The `length` value is a promise of integer.

### Future#toString

If you pasted the above into a console, you probably saw something
like this in the output:

    ip: dispatch.Future[String] = Future(-incomplete-)
    length: dispatch.Future[Int] = Future(2)

Both futures depend on the same network operation. By the time the
second is evaluated by the console, its underlying value may or may
not be available.  But if you try a moment or two later, you'll see
that both futures print their values.

    scala> country
    res2: dispatch.Future[String] = Promise(US)

`Future.toString` represents future values only if they are already
available.

### Future#completeOption

How does `toString` work on unknown values? It uses an option. You can
use the same technique to access the integer value, *if it's
available*.

```scala
val lengthNow = length.completeOption.getOrElse(-1)
```

But most of the time, you want to operate on values that are known to
be available. In the next pages we'll see how far we can go in this
direction by transforming promises.
